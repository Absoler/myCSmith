#! /bin/bash

#-----
#   this script invoke csmith to generate C files and judge 
#   whether a multi-load problem happen on a compiler
#   
#   args[1] is the number of tests
#   
#-----

# 1665 for start
# 1902 O0 => 2049
# 2049 back to O1
# no problem in O3 for 20000 tests
# 2433 try to strengthen restrictions ( rm 'fromPost' in stm_visit_facts)
# 3971 start O2
# 4200 block unexpect check in pintool for O2
if [ $# -ge 1 ]; then
    limit=$1
else
    limit=1000000000
fi
compilers=("gcc-12.1"  "icc")

# 1th line of base.out is the number of C cases, 2th line is the next of current reduced case
read base < ./base.out

cnt=0
fail_cnt=0  # recording the number of problem cases
run_err=0
while [ $cnt -lt $limit ]
# while true
do
    build/src/csmith --no-safe-math --no-bitfields --no-volatiles --probability-configuration ./prob.txt  -o runtime/output2.c 1>/dev/null
    fail=0  # fail flag
    for compiler in ${compilers[*]} ; do
        $compiler runtime/output2.c -g -w -O2 -o runtime/output2
        if [ $? -gt 0 ] ; then
            echo $compiler compilation error
        fi 
        timeout -s SIGTERM 5s ../pin-3.21-98484-ge7cd811fd-gcc-linux/pin -t checkRead/obj-intel64/checkRead.so -- runtime/output2 func 1>/dev/null
        if [ $? -gt 0 ] ; then
            ((run_err++))
            continue
        fi
        read line < ./result.out
        if [ $line == 1 ] ; then
            fail=1
            ./record.kb ${compiler} $[ base + fail_cnt ]
            echo $compiler fail
        fi    
       
    done
    
    if [ $fail == 1 ] ; then
        ((fail_cnt++))
        sed "1c $[base+fail_cnt]" -i base.out
    fi

    if [ $[cnt%1000] == 0 ] ; then
        echo $cnt cases tested
        echo pin error $run_err
    fi
    
    ((cnt++))
done

printf "%d cases tested\n" $cnt
